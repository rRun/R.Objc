//
//  ResourcesGenerator.m
//  R.Objc
//
//  Created by 何霞雨 on 2017/5/4.
//  Copyright © 2017年 何霞雨. All rights reserved.
//

#import "ResourcesGenerator.h"

#import "ImagesProperty.h"
#import "PathsProperty.h"
#import "StringKeysProperty.h"
#import "ImageProperty.h"
#import "PathProperty.h"

#import "ClassGenerator.h"
#import "CPrint.h"

#import "XCodeGroup.h"
#import "XcodeFile.h"

#import "NSString+R.h"


static NSString *const LocalizableStringName = @"Localizable.strings";

@interface ResourcesGenerator ()
@property(nonatomic, strong) XcodeProj *xcodeProj;

@property(nonatomic, strong) ImagesProperty *imagesRoot;
@property(nonatomic, retain) PathsProperty *pathsRoot;
@property(nonatomic, retain) StringKeysProperty *stringKeysRoot;

@end


@implementation ResourcesGenerator

- (id)initWithProjectFile:(NSString *)aPath {
    self = [super init];
    if (self == nil) {
        return nil;
    }
    
    self.xcodeProj = [[XcodeProj alloc]
                       initWithPath:aPath
                       environment:[[NSProcessInfo processInfo] environment]];
    if (self.xcodeProj == nil) {
        return nil;
    }
    
    self.imagesRoot = [[ImagesProperty alloc]
                        initWithName:@""
                        parent:nil
                        path:@""
                        className:@"RImages"]
                       ;
    self.pathsRoot = [[PathsProperty alloc]
                       initWithName:@""
                       parent:nil
                       path:@""
                       className:@"RPaths"];
    self.stringKeysRoot = [[StringKeysProperty alloc]
                            initWithName:@""
                            parent:nil
                            path:@""
                            className:@"RStrings"];
    
    return self;
}

- (void)writeResoucesTo:(NSString *)outputDir
              className:(NSString *)className
              forTarget:(NSString *)targetName{
    NSString *headerFile = [className stringByAppendingPathExtension:@"h"];
    NSString *implementationFile = [className stringByAppendingPathExtension:@"m"];
    NSMutableString *header = [NSMutableString string];
    NSMutableString *implementation = [NSMutableString string];
    
    NSMutableArray *classes = [NSMutableArray array];
    if (self.optionGenerateImages) {
        [classes addObject:self.imagesRoot];
    }
    if (self.optionGeneratePaths) {
        [classes addObject:self.pathsRoot];
    }
    if (self.optionGenerateStringKeys) {
        [classes addObject:self.stringKeysRoot];
    }
    
    [self loadResourcesForTarget:targetName];
    
    
    // 清除没有文件需要生成的类生产器
    for (ClassProperty *classProperty in classes) {
        [classProperty pruneEmptyClasses];
    }
    
    //生成代码文件
    NSMutableString *generatedBy = [NSMutableString string];
    [generatedBy appendString:@"// This file was generated by rgen\n"];
    [generatedBy appendFormat:@"// Project: %@\n", [self.xcodeProj projectName]];
    if (targetName != nil) {
        [generatedBy appendFormat:@"// Target : %@\n", targetName];
    }
    [generatedBy appendString:@"\n"];
    [header appendString:generatedBy];
    [header appendString:@"#import <UIKit/UIKit.h>\n\n"];
    [implementation appendString:generatedBy];
    [implementation appendFormat:@"#import \"%@\"\n\n", headerFile];
    
    for (ClassProperty *classProperty in classes) {
        [classProperty rescursePreOrder:^(NSArray *propertyPath,
                                          ClassProperty *classProperty) {
            [header appendFormat:@"@class %@;\n", classProperty.className];
        }];
        [header appendString:@"\n"];
    }
    
    for (ClassProperty *classProperty in classes) {
        [header appendString:[classProperty headerProlog:self]];
        [header appendString:@"\n"];
    }
    
    for (ClassProperty *classProperty in classes) {
        [implementation appendString:[classProperty implementationProlog:self]];
        [implementation appendString:@"\n"];
    }
  
    for (ClassProperty *classProperty in classes) {
        [classProperty rescursePreOrder:^(NSArray *propertyPath,
                                          ClassProperty *classProperty) {
            ClassGenerator *classGenerator = [[ClassGenerator alloc]
                                               initWithClassName:classProperty.className
                                               inheritName:[classProperty inheritClassName]];
            [classProperty generate:classGenerator generator:self];
            
            [header appendString:[classGenerator header]];
            [header appendString:@"\n"];
            [implementation appendString:[classGenerator implementation]];
            [implementation appendString:@"\n"];
        }];
    }
    
    
    //将生成的文件创建工程依赖
    NSString *headerPath = [NSString pathWithComponents:
                            [NSArray arrayWithObjects:
                             outputDir, headerFile, nil]];
    NSString *implementationPath = [NSString pathWithComponents:
                                    [NSArray arrayWithObjects:
                                     outputDir, implementationFile, nil]];
    
    NSString *oldHeader = [NSString stringWithContentsOfFile:headerPath
                                                    encoding:NSUTF8StringEncoding
                                                       error:NULL];
    NSString *oldImplementation = [NSString stringWithContentsOfFile:implementationPath
                                                            encoding:NSUTF8StringEncoding
                                                               error:NULL];
    if (oldHeader != nil && [header isEqualToString:oldHeader] &&
        oldImplementation != nil && [implementation isEqualToString:oldImplementation]) {
        ptrace(@"Both header (%@) and implementation (%@) is same as on file system. "
              @"Skipping write.",
              headerPath, implementationPath);
        return;
    }

    
    if ([header writeToFile:headerPath
                 atomically:YES
                   encoding:NSUTF8StringEncoding
                      error:NULL]) {
        ptrace(@"Write header to %@", headerPath);
    } else {
        [self raiseFormat:@"Failed to write header to %@", headerPath];
    }
    if ([implementation writeToFile:implementationPath
                         atomically:YES
                           encoding:NSUTF8StringEncoding
                              error:NULL]) {
        ptrace(@"Write implementation to %@", implementationPath);
    }  else {
        [self raiseFormat:@"Failed to write implementation to %@", implementationPath];
    }
}


- (void)loadResourcesForTarget:(NSString *)targetName {
    __block BOOL targetFound = (targetName == nil);
    
    @try {
        [self.xcodeProj forEachBuildResource:^(NSString *buildTargetName,
                                               XCodeNode *xcodeNode) {
            if (targetName != nil && ![targetName isEqualToString:buildTargetName]) {
                return;
            }
            targetFound = YES;
            
            if ([xcodeNode isKindOfClass:[XCodeGroup class]]) {
                for (XCodeNode *groupXCodeNode in ((XCodeGroup *)xcodeNode).children) {
                    if ([groupXCodeNode isKindOfClass:[XcodeFile class]] &&
                        [groupXCodeNode.path hasSuffix:LocalizableStringName]) {
                        NSString *path = [groupXCodeNode absolutePath];
                        if (path == nil) {
                            [self raiseFormat:
                             @"%@: Could resolve path to localizable string path=@% sourceTree=%@",
                             buildTargetName, groupXCodeNode.path, groupXCodeNode.sourceTree];
                        }
                        
                        [self addLocalizableStrings:[groupXCodeNode absolutePath]
                                         targetName:buildTargetName];
                    }
                }
            } else {
                [self loadFileReference:(XcodeFile *)xcodeNode targetName:buildTargetName];
            }
        }];
    } @catch (NSException *e) {
        [self raiseFormat:@"%@", e.reason];
    }
    
    if (!targetFound) {
        [self raiseFormat:@"Could not find target \"%@\"", targetName];
    }
}

- (void)loadFileReference:(XcodeFile *)xcodeFile
               targetName:(NSString *)targetName {
    NSString *name = xcodeFile.name;
    BOOL isDir = NO;
    NSString *absPath = [xcodeFile absolutePath];
    
    if (absPath == nil) {
        [self raiseFormat:
         @"%@: Could not resolve absolute path for path %@ source tree %@",
         targetName, xcodeFile.path, xcodeFile.sourceTree];
    }
    
    if (xcodeFile.name == nil) {
        name = [xcodeFile.path lastPathComponent];
    }
    
    if ([[NSFileManager defaultManager] fileExistsAtPath:absPath
                                             isDirectory:&isDir] && isDir) {
        ptrace(@"%@: Loading folder reference \"%@\" with path %@",
              targetName, name, absPath);
        
        NSArray *subpaths = [[NSFileManager defaultManager]
                             subpathsOfDirectoryAtPath:absPath
                             error:NULL];
        if (subpaths == nil) {
            [self raiseFormat: @"%@: Failed to read directory at path %@",
             targetName, absPath];
        }
        
        for (NSString *subpath in subpaths) {
            if ([[NSFileManager defaultManager]
                 fileExistsAtPath:[absPath stringByAppendingPathComponent:subpath]
                 isDirectory:&isDir] &&
                isDir) {
                continue;
            }
            
            NSString *filename = [subpath lastPathComponent];
            // prefix path with reference folder name
            NSArray *subpathComponents = [subpath pathComponents];
            subpathComponents = [subpathComponents subarrayWithRange:
                                 NSMakeRange(0, [subpathComponents count]-1)];
            NSArray *dirComponents = [[NSArray arrayWithObject:name]
                                      arrayByAddingObjectsFromArray:subpathComponents];
            
            if ([filename isEqualToString:LocalizableStringName]) {
                [self addLocalizableStrings:[NSString pathWithComponents:
                                             [NSArray arrayWithObjects:
                                              absPath,
                                              subpath,
                                              nil]]
                                 targetName:targetName];
            } else {
                [self addImage:dirComponents
                          name:filename
                          path:[NSString pathWithComponents:
                                [dirComponents arrayByAddingObject:filename]]];
            }
            
            [self addPath:dirComponents
                     name:filename
                     path:[NSString pathWithComponents:
                           [dirComponents arrayByAddingObject:filename]]];
        }
    } else {
        ptrace(@"%@: Loading group file \"%@\"", targetName, name);
        
        [self addImage:[NSArray array]
                  name:name
                  path:name];
        [self addPath:[NSArray array]
                 name:name
                 path:name];
    }
    
}

- (void)addPath:(NSArray *)dirComponents
           name:(NSString *)name
           path:(NSString *)path {
    if (!self.optionGeneratePaths) {
        return;
    }
    
    NSString *propertyName = [name propertyName];
    
    ClassProperty *classProperty = [self.pathsRoot
                                    lookupPropertyPathFromDir:dirComponents];
    if (![classProperty isKindOfClass:[PathsProperty class]]) {
        [self raiseFormat:
         @"Path property path name collision between path %@ and %@",
         classProperty.path, path];
    }
    
    Property *property = [classProperty.properties objectForKey:propertyName];
    if (property != nil) {
        if([path isEqualToString:property.path]) {
            ptrace(@"Ignoring duplicate resource for path %@", path);
        } else {
            [self raiseFormat:
             @"Path Property name collision for %@ between paths %@ and %@",
             propertyName, ((Property *)property).path, path];
        }
    } else {
        [classProperty.properties
         setObject:[[PathProperty alloc]
                     initWithName:propertyName
                     path:path]
         forKey:propertyName];
        
        ptrace(@"Added path property name %@ for path %@",
              propertyName, path);
    }
}


- (void)addImage:(NSArray *)dirComponents
            name:(NSString *)name
            path:(NSString *)path {
    if (!self.optionGenerateImages) {
        return;
    }
    
    NSString *propertyName = [name imagePropertyName:self.optionIpadImageSuffx];
    NSString *normalizedPath = [path normalizeIOSPath:self.optionIpadImageSuffx];
    
    ClassProperty *classProperty = [self.imagesRoot
                                    lookupPropertyPathFromDir:dirComponents];
    if (![classProperty isKindOfClass:[ImagesProperty class]]) {
        [self raiseFormat:
         @"Image property path name collision between path %@ and %@ (real %@)",
         classProperty.path, normalizedPath, path];
    }
    
    Property *property = [classProperty.properties objectForKey:propertyName];
    if (property != nil) {
        if([normalizedPath isEqualToString:property.path]) {
            ptrace(@"Ignoring duplicate resource for path %@ (real %@)",
                  normalizedPath, path);
        } else {
            [self raiseFormat:
             @"Image property name collision for %@ between paths %@ and %@ (real %@)",
             propertyName, ((Property *)property).path, normalizedPath, path];
        }
    } else {
        NSString *ext = [[path pathExtension] lowercaseString];
        if ([ext isSupportedImageExtByIOS]) {
            [classProperty.properties
             setObject:[[ImageProperty alloc]
                         initWithName:propertyName
                         path:normalizedPath]
             forKey:propertyName];
            
            ptrace(@"Added image property name %@ for path %@ (real %@)",
                  propertyName, normalizedPath, path);
        } else {
            ptrace(@"Ignoring unknown resource for path %@ (real %@)",
                  normalizedPath, path);
        }
    }
}


- (void)addLocalizableStrings:(NSString *)path
                   targetName:(NSString *)targetName {
    if (!self.optionGenerateStringKeys) {
        return;
    }
    
    ptrace(@"Reading localizable strings file with path %@", path);
    
    NSString *stringsData = [NSString stringWithContentsOfFile:path
                                                      encoding:NSUTF8StringEncoding
                                                         error:NULL];
    if (stringsData == nil) {
        [self raiseFormat:@"%@: Failed to read localizable strings file %@",
         targetName, path];
    }
    
    NSDictionary *strings = [stringsData propertyListFromStringsFileFormat];
    if (strings == nil) {
        [self raiseFormat:@"%@: Failed to deserialize file %@",
         targetName, path];
    }
    
    for (NSString *key in [strings allKeys]) {
        NSString *propertyName = [key propertyName];
        
        [self.stringKeysRoot.properties
         setObject:[[Property alloc] initWithName:propertyName
                                              path:key]
         forKey:propertyName];
        
        ptrace(@"Added string key property name %@ for key \"%@\"",
              propertyName, key);
    }
}

- (void)raiseFormat:(NSString *)format, ... {
    if (self.xcodeProj != nil) {
        format = [@": " stringByAppendingString:format];
        format = [[self.xcodeProj projectName] stringByAppendingString:format];
    }
    
    va_list va;
    va_start(va, format);
    [ResourcesGeneratorException raise:@"error" format:format arguments:va];
    va_end(va);
}
@end

@implementation ResourcesGeneratorException
@end
